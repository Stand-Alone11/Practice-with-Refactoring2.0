# practice-with-Refactoring2.0
practice with Refactoring2.0 written by Martin Fowler<br>
각 챕터별 브랜치의 리퀘스트를 통해 커밋 이력을 볼 수 있다.

## Chap 1. 첫번째 예시

리팩터링 2판의 예시는 자바스크립트로 이뤄져있다.<br>
코틀린에 익숙해지기 위해 코틀린으로 코드를 바꿔 연습한다.<br>
커밋 히스토리로 리팩터링 과정을 기록한다.<br>

### todo

리팩토링에 앞서 반드시 테스트를 준비한다.<br>
- kotlin을 위한 테스트 도구인 kotest를 이용하여 테스트 준비
- 결과 스트링을 비교하는 코드로 작성함

각 리팩토링 과정의 목적을 생각하며 진행한다.

### thinking & opinion

- 아주 유연한 자바스크립트를 코틀린으로 변환시키면서 생기는 문제점들이 있었다.
  - 이미 존재하는 객체에 새로운 프로퍼티를 추가하기
    - 해결방법: 임시 클래스를 만들면서 진행하거나, 기존 클래스에 프로퍼티를 추가함
    - 그러나 이렇게 진행하는 것이 올바른지 의문이 생김
- 클래스나, 함수로 추출하고 이전에 사용했던 변수, 함수를 추출한 클래스의 객체, 함수로 바꿀 때 꼼꼼하게 체크해야 한다
  - 실수할 수 있는 부분이라 반드시 테스트를 거쳐야 한다.
  - 테스트 코드를 통해 오류를 바로 발견할 수 있었다. 테스트야 고마워
- 테스트 코드 짜기가 생각보다 쉽지않다.
  - 리팩토링에 앞서 바꾸고자 하는 부분의 테스트를 마련해야하는데 아직 익숙하지 않다.
- 깃 커밋을 아주 잘게 쪼개는 연습이 되었다.
  - 코딩을 할 때, 구현에 급급하여 커밋을 수시로 하지 않았었다.
  - 실수가 발생했을 때 한참 전의 커밋으로 돌아가던가, 틀린 부분만 분석하여 다시 고쳤었다. 시간이 오래 걸렸다.
  - 단위 커밋이 작아지면 메시지 작성이 귀찮지만 결국 생산성이 더 좋아진다.

## Chap 2. 리팩터링 원칙 - .md only

> 정의
>
> 소프트웨어의 겉보기 동작*은 그래도 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법 혹은 변경하기
>
> 겉보기 동작: 리팩터링 전과 후의 코드가 같은 결과 혹은 동작을 해야함

리팩터링은 정의에 따라 `특정 방식으로` 코드 구조를 바꾸는 것이다. 즉 겉보기 동작을 그대로 유지한 채, 작은 리팩터링 단계들을 연결하여 큰 변화를 이끌어 낸다.

- 리팩터링은 버그 픽스를 하지 않는다. 기능 추가도 하지 않는다.
- 리팩터링은 성능 개선이 목적이 아니다. 코드를 이해하고 수정하기 쉽게 바꾸는 것이 목적이다.

### 리팩터링하는 이유

- 소프트웨어 설계 개선
- 소프트웨어 이해 쉬워짐
  - 타인이 작성한 코드도 이해하기 쉬워지므로 협업에서 강한 강점
- 버그 찾기 쉬워짐
  - 리팩터링 과정을 통해 코드가 하는 일을 깊게 이해할 수 있고, 코드 구조를 더욱 명확히 다듬을 수 있다.
  - 코드가 명확해지면 버그는 지나칠 수 없다.
- 프로그래밍 속도 상승
  - 흔히 리팩토링을 하게되면 시간을 소모한다는 이미지가 있다.
  - 그러나 리팩토링을 통해 코드 구조가 명확해지면, 추후 기능을 추가할 때 훨씬 빨라진다.

### 언제 리팩터링 하는가?

1. 그냥 코딩한다.
2. 비슷한 일을 두 번째로 하게되어도 계속 진행한다.
3. 3 strike out. 리팩터링 하자!

### thinking & opinion

- 리팩터링은 따로 시간을 내서 하는 것이 아니다. 좋은 습관처럼 수시로 해야한다.
- 앞서 커밋을 잘게 나눠 메세지를 작성하는 것처럼 귀찮고 시간이 조금 더 소요되지만 결국 생산성이 좋아진다.
- 언제 리팩터링을 진행해야 하는지 판단하는 것은 아직 감이 안잡힌다.
